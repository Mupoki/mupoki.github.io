<!DOCTYPE html>
<html>
<head>
<meta name="google-adsense-account" content="ca-pub-1263564566192061">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Mini GTA: Drive, Walk, Enter House</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#000}
  canvas{display:block}
  /* HUD */
  #hud {position:fixed; left:12px; bottom:12px; z-index:20; color:#fff; font:14px system-ui;}
  #speed {font-weight:700; margin-top:6px}
  /* Touch controls */
  .pad {position:fixed; bottom:16px; right:16px; z-index:25;
        display:grid; grid-template-columns:repeat(3,64px); grid-template-rows:repeat(2,64px); gap:10px; user-select:none}
  .btn {border:none; border-radius:14px; color:#fff; font:20px/1.1 system-ui; font-weight:700;
        background:rgba(0,0,0,.45); backdrop-filter:blur(4px)}
  .btn:active{transform:scale(.98)}
  /* Interact hint */
  #hint {position:fixed; top:12px; left:50%; transform:translateX(-50%);
         color:#fff; font:13px system-ui; background:rgba(0,0,0,.35); padding:6px 10px; border-radius:8px; z-index:20; opacity:.9}
</style>
</head>
<body>
<div id="hint">WASD / Arrows to move ‚Ä¢ E = In/Out of car ‚Ä¢ F = Use door</div>
<div id="hud">
  <div>Mode: <span id="mode">DRIVE</span></div>
  <div id="speed">0 km/h</div>
</div>

<!-- Touch controls -->
<div class="pad">
  <button class="btn" id="turnL">‚üµ</button>
  <button class="btn" id="accel">‚Üë</button>
  <button class="btn" id="turnR">‚ü∂</button>
  <button class="btn" id="brake">‚Üì</button>
  <button class="btn" id="toggle">üö∂/üöó</button>
  <button class="btn" id="use">üö™</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
/* =========================
   Basic Setup
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 6000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);
addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);});

const sun = new THREE.DirectionalLight(0xffffff,1.1); sun.position.set(200,400,150); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048);
scene.add(sun); scene.add(new THREE.AmbientLight(0x777777));

/* =========================
   Procedural Textures (CORS-safe)
========================= */
function repeatTex(draw,w=256,h=256,rx=1,ry=1){
  const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); draw(ctx,w,h);
  const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(rx,ry); t.anisotropy=8; return t;
}
const grassTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#2b8a3e';ctx.fillRect(0,0,w,h);for(let i=0;i<1200;i++){ctx.fillStyle=`rgb(20,${80+Math.random()*80|0},20)`;ctx.fillRect(Math.random()*w,Math.random()*h,1,1);}},256,256,64,64);
const asphaltTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#2e2e2e';ctx.fillRect(0,0,w,h);ctx.fillStyle='#3a3a3a';for(let i=0;i<900;i++){ctx.fillRect(Math.random()*w,Math.random()*h,1,1);}},256,256,1,48);
const laneTex = repeatTex((ctx,w,h)=>{ctx.clearRect(0,0,w,h);ctx.fillStyle='#fff';for(let y=0;y<h;y+=64){ctx.fillRect(w/2-4,y,8,32)}},256,256,1,48);
const sidewalkTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#b8b8b8';ctx.fillRect(0,0,w,h);ctx.strokeStyle='#a0a0a0';for(let x=0;x<w;x+=32){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}for(let y=0;y<h;y+=24){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}},256,256,16,16);
const windowsTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#141418';ctx.fillRect(0,0,w,h);for(let y=8;y<h;y+=18){for(let x=8;x<w;x+=18){const on=Math.random()>.35;ctx.fillStyle=on?'#aee1ff':'#0d0d18';ctx.fillRect(x,y,12,12);ctx.fillStyle='rgba(255,255,255,.06)';ctx.fillRect(x,y,12,6);}}},256,256,4,4);
const brickTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#8a4b2a';ctx.fillRect(0,0,w,h);ctx.fillStyle='#a96642';const bh=18,bw=36;for(let y=0;y<h;y+=bh){const off=(y/bh)%2?bw/2:0;for(let x=-off;x<w;x+=bw){ctx.fillRect(x,y,bw-2,bh-2)}}ctx.strokeStyle='rgba(0,0,0,.2)';for(let y=0;y<h;y+=bh){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}for(let x=0;x<w;x+=bw){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}},256,256,4,4);

/* =========================
   World & City Grid
========================= */
const ground = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), new THREE.MeshLambertMaterial({map:grassTex}));
ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

const ROAD_W=18, SIDEWALK_W=6, BLOCK=130, GRID=7, half=Math.floor(GRID/2);
const city = new THREE.Group(); scene.add(city);

function roadStrip(x,z,len,dir='z'){
  const g=new THREE.Group();
  const asphalt=new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W,len), new THREE.MeshLambertMaterial({map:asphaltTex}));
  asphalt.rotation.x=-Math.PI/2; asphalt.receiveShadow=true; g.add(asphalt);
  const lanes=new THREE.Mesh(new THREE.PlaneGeometry(2,len), new THREE.MeshBasicMaterial({map:laneTex,transparent:true}));
  lanes.rotation.x=-Math.PI/2; lanes.position.y=0.01; g.add(lanes);
  const swL=new THREE.Mesh(new THREE.PlaneGeometry(SIDEWALK_W,len), new THREE.MeshLambertMaterial({map:sidewalkTex}));
  swL.rotation.x=-Math.PI/2; swL.position.set(-ROAD_W/2-SIDEWALK_W/2,0.02,0); g.add(swL);
  const swR=swL.clone(); swR.position.x=+ROAD_W/2+SIDEWALK_W/2; g.add(swR);
  if(dir==='x') g.rotation.y=Math.PI/2;
  g.position.set(x,0,z); city.add(g);
}
for(let i=-half;i<=half;i++){ roadStrip(i*BLOCK,0,GRID*BLOCK,'z'); roadStrip(0,i*BLOCK,GRID*BLOCK,'x'); }

/* =========================
   Buildings & Better Houses
========================= */
const structures = new THREE.Group(); city.add(structures);
function makeBuilding(x,z){
  const h=40+Math.random()*140;
  const mat=new THREE.MeshLambertMaterial({map: Math.random()>.4? windowsTex : brickTex});
  const b=new THREE.Mesh(new THREE.BoxGeometry(42,h,42),mat); b.position.set(x,h/2,z); b.castShadow=true; b.receiveShadow=true; return b;
}
// ‚ÄúGame-like‚Äù house with door, windows, gable roof
function makeHouse(x,z){
  const body=new THREE.Mesh(new THREE.BoxGeometry(38,18,28), new THREE.MeshLambertMaterial({map:brickTex}));
  body.position.set(x,9,z); body.castShadow=true; body.receiveShadow=true;
  // windows strips
  const win=new THREE.Mesh(new THREE.BoxGeometry(36,1,0.5), new THREE.MeshBasicMaterial({map:windowsTex}));
  const w1=win.clone(); w1.position.set(x,13,z-14.5);
  const w2=win.clone(); w2.position.set(x,8,z-14.5);
  const w3=win.clone(); w3.position.set(x,-13,z-14.5); // back hidden but okay
  // door
  const door=new THREE.Mesh(new THREE.BoxGeometry(3,6,0.6), new THREE.MeshLambertMaterial({color:0x6b4a2f}));
  door.position.set(x-8,3.2,z+14.6);
  door.userData.isDoor=true; // tag
  // roof (gable)
  const roof=new THREE.Mesh(new THREE.ConeGeometry(28,10,4), new THREE.MeshLambertMaterial({color:0x5a4633}));
  roof.position.set(x,23,z); roof.rotation.y=Math.PI/4; roof.castShadow=true;
  const g=new THREE.Group(); g.add(body,w1,w2,door,roof); return g;
}
// Populate corners of blocks
let specialHouseDoor; // we'll store one door for interior entry
for(let gx=-half; gx<=half; gx++){
  for(let gz=-half; gz<=half; gz++){
    const wx=gx*BLOCK, wz=gz*BLOCK;
    const placeHouse = Math.random()>.5;
    if(placeHouse){
      const h1=makeHouse(wx+44,wz+44); structures.add(h1);
      const h2=makeHouse(wx-44,wz-44); structures.add(h2);
      // remember one specific house door
      if(!specialHouseDoor){
        h1.traverse(o=>{ if(o.userData.isDoor) specialHouseDoor=o; });
      }
    }else{
      structures.add(makeBuilding(wx+44,wz+44));
      structures.add(makeBuilding(wx-44,wz-44));
    }
    // opposite corners
    if(Math.random()>.5){ structures.add(makeHouse(wx+44,wz-44)); } else { structures.add(makeBuilding(wx+44,wz-44)); }
    if(Math.random()>.5){ structures.add(makeHouse(wx-44,wz+44)); } else { structures.add(makeBuilding(wx-44,wz+44)); }
  }
}

/* =========================
   Car (detailed boxy) + Player Capsule
========================= */
function detailedCar(color=0xff3030){
  const car=new THREE.Group();
  const body=new THREE.Mesh(new THREE.BoxGeometry(4.6,1.2,9.2), new THREE.MeshPhongMaterial({color, shininess:120, specular:0x222222}));
  body.position.y=1.4; body.castShadow=body.receiveShadow=true; car.add(body);
  const cabin=new THREE.Mesh(new THREE.BoxGeometry(3.6,1.2,3.0), new THREE.MeshPhongMaterial({color:0x88aaff,transparent:true,opacity:0.6}));
  cabin.position.y=2.2; car.add(cabin);
  const bumperF=new THREE.Mesh(new THREE.BoxGeometry(4.8,0.5,0.6), new THREE.MeshLambertMaterial({color:0x222222}));
  const bumperR=bumperF.clone(); bumperF.position.set(0,0.8,-4.8); bumperR.position.set(0,0.8,4.8); car.add(bumperF,bumperR);
  const headL=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.3,0.2), new THREE.MeshBasicMaterial({color:0xffffcc}));
  const headR=headL.clone(); headL.position.set(-1.2,1.2,-4.6); headR.position.set(1.2,1.2,-4.6); car.add(headL,headR);
  const tailL=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.3,0.2), new THREE.MeshBasicMaterial({color:0xff2222}));
  const tailR=tailL.clone(); tailL.position.set(-1.2,1.2,4.6); tailR.position.set(1.2,1.2,4.6); car.add(tailL,tailR);
  function wheel(){const g=new THREE.Group();
    const tire=new THREE.Mesh(new THREE.CylinderGeometry(1.05,1.05,0.7,20), new THREE.MeshLambertMaterial({color:0x141414}));
    const rim=new THREE.Mesh(new THREE.CylinderGeometry(0.65,0.65,0.72,8), new THREE.MeshPhongMaterial({color:0xdddddd,shininess:100}));
    tire.rotation.z=rim.rotation.z=Math.PI/2; tire.castShadow=true; g.add(tire,rim); return g;}
  const wFL=wheel(),wFR=wheel(),wRL=wheel(),wRR=wheel();
  wFL.position.set(-2.1,0.9,-3); wFR.position.set(2.1,0.9,-3); wRL.position.set(-2.1,0.9,3); wRR.position.set(2.1,0.9,3);
  car.add(wFL,wFR,wRL,wRR); car.userData.wheels={wFL,wFR,wRL,wRR};
  car.castShadow=car.receiveShadow=true; return car;
}
const playerCar = detailedCar(0xff3333); scene.add(playerCar); playerCar.position.set(0,0,20);

function makeCapsule(height=3,r=0.6,color=0xeeeeee){
  const g=new THREE.Group();
  const cyl=new THREE.Mesh(new THREE.CylinderGeometry(r,r,height-2*r,12), new THREE.MeshLambertMaterial({color}));
  const sTop=new THREE.Mesh(new THREE.SphereGeometry(r,12,12), new THREE.MeshLambertMaterial({color}));
  const sBot=sTop.clone();
  cyl.position.y=r+(height-2*r)/2; sTop.position.y=height-r; sBot.position.y=r;
  g.add(cyl,sTop,sBot); g.castShadow=true; return g;
}
const onFoot = makeCapsule(3,0.6,0xe6e6e6); scene.add(onFoot); onFoot.visible=false;

/* =========================
   Interior Scene (simple room)
========================= */
const interior = new THREE.Group(); interior.visible=false; scene.add(interior);
const room = new THREE.Group(); interior.add(room);
const roomFloor = new THREE.Mesh(new THREE.PlaneGeometry(30,24), new THREE.MeshLambertMaterial({color:0xd9d2c7}));
roomFloor.rotation.x=-Math.PI/2; room.add(roomFloor);
const wallMat=new THREE.MeshLambertMaterial({color:0xe9e3da});
const walls=[
  new THREE.Mesh(new THREE.BoxGeometry(30,8,0.5), wallMat),
  new THREE.Mesh(new THREE.BoxGeometry(30,8,0.5), wallMat),
  new THREE.Mesh(new THREE.BoxGeometry(0.5,8,24), wallMat),
  new THREE.Mesh(new THREE.BoxGeometry(0.5,8,24), wallMat)
];
walls[0].position.set(0,4,-12); walls[1].position.set(0,4,12);
walls[2].position.set(-15,4,0); walls[3].position.set(15,4,0);
walls.forEach(w=>{w.castShadow=w.receiveShadow=true; room.add(w);});
const table=new THREE.Mesh(new THREE.BoxGeometry(6,0.4,3), new THREE.MeshLambertMaterial({color:0x6b4a2f}));
table.position.set(0,2,0); const legs=[];
for(let dx of [-2.6,2.6]) for(let dz of [-1.3,1.3]){
  const leg=new THREE.Mesh(new THREE.BoxGeometry(0.3,2,0.3), new THREE.MeshLambertMaterial({color:0x5a4633}));
  leg.position.set(dx,1,dz); legs.push(leg);
}
room.add(table, ...legs);
// interior door position (to exit)
const interiorDoorPos = new THREE.Vector3(0,0,11); // near z=+12 wall

/* =========================
   Controls & State
========================= */
const keys={};
addEventListener('keydown',e=>{keys[e.key.toLowerCase()]=true;});
addEventListener('keyup',e=>{keys[e.key.toLowerCase()]=false;});
const ui = {mode:document.getElementById('mode'), speedEl:document.getElementById('speed')};

const presses={accel:false,brake:false,turnL:false,turnR:false,toggle:false,use:false};
function bind(id,prop){
  const el=document.getElementById(id);
  const on=(e)=>{e.preventDefault(); presses[prop]=true;};
  const off=(e)=>{e.preventDefault(); presses[prop]=false;};
  el.addEventListener('touchstart',on,{passive:false}); el.addEventListener('touchend',off,{passive:false});
  el.addEventListener('mousedown',on); el.addEventListener('mouseup',off); el.addEventListener('mouseleave',off);
}
['turnL','turnR','accel','brake','toggle','use'].forEach(id=>bind(id,id));

let mode='DRIVE'; // DRIVE | FOOT | INTERIOR
let carSpeed=0, carAngle=Math.PI, footSpeed=0, footAngle=0;
const accel=0.06, brake=0.16, maxSpeed=2.8, friction=0.98, turnRate=0.04;
const footAccel=0.035, footMax=0.9, footFriction=0.86;

function updateHUD(){
  ui.mode.textContent=mode;
  const kmh = mode==='DRIVE' ? Math.max(0,Math.abs(carSpeed)*110) : Math.max(0,Math.abs(footSpeed)*30);
  ui.speedEl.textContent = `${kmh.toFixed(0)} km/h`;
}

/* Helpers */
function moveForward(obj, angle, dist){ obj.position.x += Math.sin(angle)*dist; obj.position.z += Math.cos(angle)*dist; }
function wrapCity(obj){ const lim=half*BLOCK+30; if(obj.position.x>lim)obj.position.x=-lim; if(obj.position.x<-lim)obj.position.x=lim; if(obj.position.z>lim)obj.position.z=-lim; if(obj.position.z<-lim)obj.position.z=lim; }
function dist(a,b){return a.distanceTo(b);}

/* Toggle in/out of car (E or touch) */
function tryToggleVehicle(){
  if(mode==='DRIVE'){
    // exit car: spawn capsule at driver side
    onFoot.position.copy(playerCar.position);
    onFoot.position.x += Math.cos(carAngle)*-1.2; // small offset
    onFoot.position.z += Math.sin(carAngle)*1.2;
    onFoot.visible=true; mode='FOOT';
  }else if(mode==='FOOT'){
    // only enter if near car
    if(onFoot.position.distanceTo(playerCar.position)<3.5){
      onFoot.visible=false; mode='DRIVE';
      // snap camera nicely behind
    }
  }else if(mode==='INTERIOR'){
    // cannot toggle inside
  }
}

/* Use / door handling (F or touch) */
function tryUse(){
  if(mode==='FOOT'){
    // If near special house door => enter interior
    if(specialHouseDoor && dist(onFoot.position, specialHouseDoor.position) < 3.2){
      // switch to INTERIOR
      city.visible=false; playerCar.visible=false;
      interior.visible=true; mode='INTERIOR';
      onFoot.position.set(0,0,9); // inside room, near the door
    }
  }else if(mode==='INTERIOR'){
    // If near inside door -> exit back outside near the house door
    if(onFoot.position.distanceTo(interiorDoorPos) < 2.5){
      interior.visible=false; city.visible=true; playerCar.visible=true; mode='FOOT';
      // put player just outside the real door
      const p = specialHouseDoor.position.clone(); p.z += 2.5;
      onFoot.position.copy(p);
    }
  }
}

/* =========================
   Simple AI Traffic
========================= */
const lanes=[];
for(let i=-half;i<=half;i++){
  lanes.push({dir:'z',x:i*BLOCK-ROAD_W*0.25,z1:-half*BLOCK,z2:half*BLOCK});
  lanes.push({dir:'z',x:i*BLOCK+ROAD_W*0.25,z1:half*BLOCK,z2:-half*BLOCK});
  lanes.push({dir:'x',z:i*BLOCK-ROAD_W*0.25,x1:-half*BLOCK,x2:half*BLOCK});
  lanes.push({dir:'x',z:i*BLOCK+ROAD_W*0.25,x1:half*BLOCK,x2:-half*BLOCK});
}
function spawnAI(color=0x3399ff){
  const c=detailedCar(color);
  const lane=lanes[Math.random()*lanes.length|0];
  let angle=0, x=0, z=0, speed=0.8+Math.random()*0.8;
  if(lane.dir==='z'){ x=lane.x; z=lane.z1; angle=(lane.z2>lane.z1)?0:Math.PI; }
  else { z=lane.z; x=lane.x1; angle=(lane.x2>lane.x1)?Math.PI/2:-Math.PI/2; }
  c.position.set(x,0,z); c.rotation.y=angle; scene.add(c);
  return {car:c,angle,speed};
}
const traffic=[]; for(let i=0;i<14;i++) traffic.push(spawnAI(Math.random()>.5?0x3399ff:0xffcc33));

/* =========================
   Main Loop
========================= */
function animate(){
  requestAnimationFrame(animate);

  // key/touch states
  const forward = keys['arrowup']||keys['w']||presses.accel;
  const back    = keys['arrowdown']||keys['s']||presses.brake;
  const left    = keys['arrowleft']||keys['a']||presses.turnL;
  const right   = keys['arrowright']||keys['d']||presses.turnR;
  if(keys['e']||presses.toggle) { tryToggleVehicle(); keys['e']=presses.toggle=false; }
  if(keys['f']||presses.use)    { tryUse();          keys['f']=presses.use=false; }

  if(mode==='DRIVE'){
    if(forward) carSpeed += accel;
    if(back)    carSpeed -= brake*0.6;
    carSpeed *= friction;
    carSpeed = Math.max(-maxSpeed*0.5, Math.min(maxSpeed, carSpeed));
    if(left)  carAngle += turnRate*(0.5+Math.abs(carSpeed)/maxSpeed);
    if(right) carAngle -= turnRate*(0.5+Math.abs(carSpeed)/maxSpeed);
    playerCar.rotation.y=carAngle;
    moveForward(playerCar, carAngle, carSpeed);
    wrapCity(playerCar);
    // spin wheels
    const w=playerCar.userData.wheels, spin=carSpeed*0.8;
    w.wFL.rotation.x+=spin; w.wFR.rotation.x+=spin; w.wRL.rotation.x+=spin; w.wRR.rotation.x+=spin;
    // camera chase
    camera.position.x = playerCar.position.x - Math.sin(carAngle)*16;
    camera.position.z = playerCar.position.z - Math.cos(carAngle)*16;
    camera.position.y = playerCar.position.y + 7;
    camera.lookAt(playerCar.position.x, playerCar.position.y+2, playerCar.position.z);
  }
  else if(mode==='FOOT'){
    if(forward) footSpeed = Math.min(footMax, footSpeed + footAccel);
    else if(back) footSpeed = Math.max(-footMax*0.5, footSpeed - footAccel);
    else footSpeed *= footFriction;

    if(left)  footAngle += 0.06;
    if(right) footAngle -= 0.06;

    onFoot.rotation.y = footAngle;
    moveForward(onFoot, footAngle, footSpeed);
    wrapCity(onFoot);
    // follow camera (third-person)
    camera.position.x = onFoot.position.x - Math.sin(footAngle)*10;
    camera.position.z = onFoot.position.z - Math.cos(footAngle)*10;
    camera.position.y = onFoot.position.y + 6;
    camera.lookAt(onFoot.position.x, onFoot.position.y+2, onFoot.position.z);
  }
  else if(mode==='INTERIOR'){
    // simple on-foot in room
    if(forward) footSpeed = Math.min(footMax*0.8, footSpeed + footAccel*0.8);
    else if(back) footSpeed = Math.max(-footMax*0.4, footSpeed - footAccel*0.8);
    else footSpeed *= footFriction;
    if(left)  footAngle += 0.06;
    if(right) footAngle -= 0.06;
    onFoot.rotation.y = footAngle;
    moveForward(onFoot, footAngle, footSpeed);
    // clamp to room bounds
    onFoot.position.x = Math.max(-13.5, Math.min(13.5, onFoot.position.x));
    onFoot.position.z = Math.max(-9, Math.min(9, onFoot.position.z));
    // camera
    camera.position.x = onFoot.position.x - Math.sin(footAngle)*8;
    camera.position.z = onFoot.position.z - Math.cos(footAngle)*8;
    camera.position.y = onFoot.position.y + 6;
    camera.lookAt(onFoot.position.x, onFoot.position.y+2, onFoot.position.z);
  }

  // Simple traffic update
  for(const a of traffic){
    moveForward(a.car, a.angle, a.speed*0.6);
    wrapCity(a.car);
    // random turns near intersections
    const gx = Math.abs((a.car.position.x/BLOCK)-Math.round(a.car.position.x/BLOCK))<0.02;
    const gz = Math.abs((a.car.position.z/BLOCK)-Math.round(a.car.position.z/BLOCK))<0.02;
    if(gx&&gz&&Math.random()<0.02){
      const r=Math.random();
      if(r<0.33) a.angle+=Math.PI/2; else if(r<0.66) a.angle-=Math.PI/2;
      a.car.rotation.y=a.angle;
    }
    const w=a.car.userData.wheels, s=a.speed*0.6;
    w.wFL.rotation.x+=s; w.wFR.rotation.x+=s; w.wRL.rotation.x+=s; w.wRR.rotation.x+=s;
  }

  // HUD
  updateHUD();

  renderer.render(scene,camera);
}
animate();

/* Init player view */
camera.position.set(0,7,-10); camera.lookAt(playerCar.position);
</script>
</body>
</html>
